<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<link rel="stylesheet" type="text/css" href="../../style.css"/><script src="../../highlight.pack.js"></script>
<title>ContainerStorageType</title>
<base href="../../"/>
<script src="search.js"></script>
</head>
<body><div class="breadcrumbs">
<table id="results"></table>
<input type="search" id="search" placeholder="Search" onkeyup="searchSubmit(this.value, event)"/>
containers.internal.<a href="containers/internal/storage_type.html">storage_type</a>.ContainerStorageType</div>
<pre><code>public template ContainerStorageType(T)
</code></pre><div class="section">

This template is used to determine the type that a container should contain
a given type T.
</div>
<div class="section">
<p>In many cases it is not possible for a Container!(T) to hold T if T is
<b>const</b> or <b>immutable</b>. For instance, a binary heap will need to
rearrange items in its internal data storage, or an unrolled list will need
to move items within a node.</p>

<p>All containers must only return const references or const copies of data
stored within them if the contained type is const. This template exists
because containers may need to move entire items but not change internal
state of those items and D's type system would otherwise not allow this.</p>

<ul><li>If <b>T</b> is mutable (i.e. not <b>immutable</b> or <b>const</b>), this
template aliases itself to T.</li>
<li><b>Class and Interface types:</b> Rebindable is used. Using this properly
    in a container requires that <a href="https://issues.dlang.org/show_bug.cgi?id=8663">issue 8663</a> be fixed. Without this fix it is not possible to implement
    containers such as a binary heap that must compare container elements
    using <b>opCmp()</b></li>
<li><b>Struct and Union types:</b>
    <ul>        <li>Stuct and union types that have elaborate constructors,
        elaboriate opAssign, or a destructor cannot be stored in containers
        because there may be user-visible effects of discarding <b>const</b>
        or <b>immutable</b> on these struct types.</li>
        <li>Other struct and union types will be stored as non-const
        versions of themselves.</li>
    </ul></li>
<li><b>Basic types:</b> Basic types will have their const or immutable status
    removed.</li>
<li><b>Pointers:</b> Pointers will have their type constructors shifted. E.g.
    const(int*) becomes const(int)*</li>
</ul>
</div>
<div class="section"><h3>Example</h3>
<pre><code>static assert (is (ContainerStorageType!(int) == int));
static assert (is (ContainerStorageType!(const int) == int));
</code></pre>
</div>
<div class="section"><h3>Example</h3>
<pre><code>import std.typecons : Rebindable;
static assert (is (ContainerStorageType!(Object) == Object));
static assert (is (ContainerStorageType!(const(Object)) == Rebindable!(const(Object))));
</code></pre>
</div>
<div class="section"><h3>Example</h3>
<pre><code>struct A { int foo; }
struct B { void opAssign(typeof(this)) { this.foo *= 2; }  int foo;}

// A can be stored easily because it is plain data
static assert (is (ContainerStorageType!(A) == A));
static assert (is (ContainerStorageType!(const(A)) == A));

// const(B) cannot be stored in the container because of its
// opAssign. Casting away const could lead to some very unexpected
// behavior.
static assert (!is (typeof(ContainerStorageType!(const(B)))));
// Mutable B is not a problem
static assert (is (ContainerStorageType!(B) == B));

// Arrays can be stored because the entire pointer-length pair is moved as
// a unit.
static assert (is (ContainerStorageType!(const(int[])) == const(int)[]));
</code></pre>
</div>
<div class="section"><h3>Example</h3>
<pre><code>static assert (is (ContainerStorageType!(const(int*)) == const(int)*));
</code></pre>
</div>

<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
