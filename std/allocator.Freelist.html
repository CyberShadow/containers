<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<link rel="stylesheet" type="text/css" href="../style.css"/><script src="../highlight.pack.js"></script>
<title>Freelist</title>
<base href="../"/>
<script src="search.js"></script>
</head>
<body><div class="breadcrumbs">
<table id="results"></table>
<input type="search" id="search" placeholder="Search" onkeyup="searchSubmit(this.value, event)"/>
std.<a href="std/allocator.html">allocator</a>.Freelist</div>
<pre><code>struct Freelist(ParentAllocator, size_t minSize, size_t maxSize = minSize, uint batchCount = 8, size_t maxNodes = unbounded)</code></pre>
<div class="section">
, stackable on top of
another allocator. Allocation requests between  and  bytes are
rounded up to  and served from a singly-linked list of buffers
deallocated in the past. All other allocations are directed to . Due to the simplicity of free list management, allocations
from the free list are fast.
</div>
<div class="section">
If a program makes many allocations in the interval  and
then frees most of them, the freelist may grow large, thus making memory
inaccessible to requests of other sizes. To prevent that, the 
parameter allows limiting the size of the free list. Alternatively,  cleans the free list.

 attempts to reduce internal fragmentation and improve cache
locality by allocating multiple nodes at once, under the control of the  parameter. This makes  an efficient front for small
object allocation on top of a large-block allocator. The default value of  is 8, which should amortize freelist management costs to negligible
in most cases.

One instantiation is of particular interest:  puts
every deallocation in the freelist, and subsequently serves any allocation from
the freelist (if not empty). There is no checking of size matching, which would
be incorrect for a freestanding allocator but is both correct and fast when an
owning allocator on top of the free list allocator (such as ) is
already in charge of handling size checking.

</div>
<div class="section">
<h3>Functions</h3>
<table>
<tr><td><a href="std/allocator.Freelist.min74653.html">min</a></td><td></td><td>Properties for getting and setting bounds. Setting a bound is only
       possible if the respective compile-time parameter has been set to .  is defined only if both 
       and  are set to .</td></tr><tr><td><a href="std/allocator.Freelist.min74701.html">min</a></td><td></td><td>Properties for getting and setting bounds. Setting a bound is only
       possible if the respective compile-time parameter has been set to .  is defined only if both 
       and  are set to .</td></tr><tr><td><a href="std/allocator.Freelist.max74768.html">max</a></td><td></td><td>Properties for getting and setting bounds. Setting a bound is only
       possible if the respective compile-time parameter has been set to .  is defined only if both 
       and  are set to .</td></tr><tr><td><a href="std/allocator.Freelist.max74816.html">max</a></td><td></td><td>Properties for getting and setting bounds. Setting a bound is only
       possible if the respective compile-time parameter has been set to .  is defined only if both 
       and  are set to .</td></tr><tr><td><a href="std/allocator.Freelist.setBounds74871.html">setBounds</a></td><td></td><td>Properties for getting and setting bounds. Setting a bound is only
       possible if the respective compile-time parameter has been set to .  is defined only if both 
       and  are set to .</td></tr><tr><td><a href="std/allocator.Freelist.goodAllocSize76799.html">goodAllocSize</a></td><td></td><td>Returns  for sizes in the interval , and  otherwise.</td></tr><tr><td><a href="std/allocator.Freelist.allocate77085.html">allocate</a></td><td></td><td>Allocates memory either off of the free list or from the parent allocator.</td></tr><tr><td><a href="std/allocator.Freelist.owns79207.html">owns</a></td><td></td><td>If  is in the interval , returns .
   Otherwise, if  is defined, forwards to it. Otherwise,
   returns . This semantics is intended to have  handle deallocations of objects of the appropriate size,
   even for allocators that don't support  (such as ).</td></tr><tr><td><a href="std/allocator.Freelist.deallocate80016.html">deallocate</a></td><td></td><td>Intercepts deallocations and caches those of the appropriate size in the
   freelist. For all others, forwards to  or does nothing
   if  does not define .</td></tr><tr><td><a href="std/allocator.Freelist.deallocateAll80567.html">deallocateAll</a></td><td></td><td>If  defines , just forwards to it and
   reset the freelist. Otherwise, walks the list and frees each object in turn.</td></tr></table>
<h3>Variables</h3>
<table>
<tr><td><a href="std/allocator.Freelist.alignment.html">alignment</a></td><td><pre><code>uint</code></pre></td><td>Alignment is defined as . However, if , objects returned from the freelist will have a
   smaller _alignment, namely  rounded up to the nearest multiple
   of 2. This allows  to minimize internal fragmentation by
   allocating several small objects within an allocated block. Also, there is
   no disruption because no object has smaller size than its _alignment.</td></tr></table>
</div>

<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
